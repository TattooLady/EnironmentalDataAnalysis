#Lab 6: Principal Component Analysis
#Author: Lydia Scherr
#Due date: 3/7/17
#ENV-Data-Analysis-Spring2017
################

#Preliminaries
rm(list=ls())

#libraries
library(foreign)
library(lattice)
library(plyr)
library(ggplot2)
library(gridExtra)

#set up working directory
setwd("~/EDA2017/Lab6")
#read data
library(readr)
epi2016 <- read_csv("/Volumes/Sony_16SA1/EnvDataAnalysis 2017/labs/Lab 6/epi2016.csv") #39variables
View(epi2016)#39 VARIABLES 180 OBSERVATIONS
variables2016 <- read_csv("/Volumes/Sony_16SA1/EnvDataAnalysis 2017/labs/Lab 6/variables2016.csv")
View(variables2016)
variables2016 <- read_csv("/Volumes/Sony_16SA1/EnvDataAnalysis 2017/labs/Lab 6/variables2016.csv")
View(variables2016)


#remove missing values before running the PCA algorithm
variables2016<-na.omit(variables2016)
nrow(variables2016)#76
names(variables2016)#24 var

###############
#calculate the correlation matrix
variables_cor<-cor(variables2016, use="complete")
variables_cor

###########################
#Run the PCA using single value decomposition method
pca_variables<-prcomp(variables2016,center = T,scale. = T)
summary(pca_variables)

#standard dev squared is also singular values
#the variance = sum of eiegen values
e_vars<-pca_variables$sdev^2
e_vars

#########
#create scree plot to evaluate the variance explained by each PC
par(mfrow=c(1,2))
screeplot(pca_variables, main="Scree plot bar chart", xlab="Components")
screeplot(pca_variables, main="Scree plot line plot", type="line")
ls(pca_variables)
#################
#loading table
load_variables<-pca_variables$rotation

###################################
#
#Plot the principal components
sorted.loadings<-load_variables[order(load_variables[,1]),1]
Main="Loadings plot for PC1"
xlabs<-"Variable loadings"
dotplot(sorted.loadings,main=Main, xlab=xlabs, par.ylab.text = list(cex = 0.2),cex=.8, col="green")

#generate loading graph for 2nd component
sorted.loadings<-load_variables[order(load_variables[,2]),2]
Main="Loadings plot for PC2"
xlabs<-"Variable loadings"
dotplot(sorted.loadings,main=Main, xlab=xlabs, cex=.8, col="red")

#generate loading graph for 3rd component
sorted.loadings<-load_variables[order(load_variables[,3]),3]
Main="Loadings plot for PC3"
xlabs<-"Variable loadings"
dotplot(sorted.loadings,main=Main, xlab=xlabs, cex=.8, col="blue")

#generate loading graph for 4th component
sorted.loadings<-load_variables[order(load_variables[,4]),4]
Main="Loadings plot for PC4"
xlabs<-"Variable loadings"
dotplot(sorted.loadings,main=Main, xlab=xlabs, cex=.8, col="yellow")

#generate loading graph for 5th component
sorted.loadings<-load_variables[order(load_variables[,5]),5]
Main="Loadings plot for PC5"
xlabs<-"Variable loadings"
dotplot(sorted.loadings,main=Main, xlab=xlabs, cex=.8, col="purple")

#generate loading graph for 6th component
sorted.loadings<-load_variables[order(load_variables[,6]),6]
Main="Loadings plot for PC6"
xlabs<-"Variable loadings"
dotplot(sorted.loadings,main=Main, xlab=xlabs, cex=.8, col="orange")

#######################
#save loads between variables in csv format
load_variables<-as.data.frame(load_variables)
View(load_variables)
#export the loading table.
write.csv(load_variables, paste(load_variables, "load_variables.csv", sep=""))

########
#generate principal component scores - at the block level - for mapping
scores_variables<-pca_variables$x
scores_variables<-as.data.frame(scores_variables)
write.csv(scores_variables, paste(scores_variables, "scores_variables.csv", sep=""))

#select the principal component scores and save the file in csv format
# in this case, it makes sense to retain 4 components
scores_variables<-scores_variables[,1:4]

########calculated social vulnerability index using additive method
#we sum the components scores for the 4 related components

scores_variables$epi = abs(scores_variables$PC1) + abs(scores_variables$PC2) + abs(scores_variables$PC3) + abs(scores_variables$PC4)

#calculating weighted epi
#apply the eigen value as weight when we calculate the index, i.e multiply each component by eigen value
scores_variables$epi = e_vars[1]*abs(scores_variables$PC1) + e_vars[2]*abs(scores_variables$PC2) + e_vars[3]*abs(scores_variables$PC3) + e_vars[4]*abs(scores_variables$PC4)

###########
#join identifier to the output PCA dataset
#currently our data doesn't have any geographical identification, we need to join it with the original dataset
join_scores_variables<-merge(epi2016,scores_variables,by="row.names")

#########
#create a scatter plot of the EPI generated by PCA and the EPI generated by Yale/CIESIN
dev.off()
plot(join_scores_variables$`2016 EPI Score`,join_scores_variables$epi,
     pch=10,
     cex=0.5,
     cex.lab=.90, 
     cex.axis=1,
     cex.main=1, 
     ylab="PCA EPI",
     xlab="Yale EPI", 
     main="Scatter Plot Score Comparison")
